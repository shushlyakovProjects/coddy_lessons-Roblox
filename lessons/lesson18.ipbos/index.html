<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROBLOX - Lesson 18</title>
    <link rel="stylesheet" href="../../css/base.css">
    <link rel="stylesheet" href="../../css/section.css">
    <link rel="stylesheet" href="../../css/media.css">
    <link rel="icon" href="../../img/base/favicon.png">
</head>

<body>

    <!-- 
    ИНСТРУКЦИЯ
    <h1></h1>
    <h2></h2>
    <h3></h3>
    <p></p>
    <p class="story"></p>
    <p class="code"></p>
    <p class="important"></p>
    <img src="" alt="">
    <div class="box__images2"> 
    -->

    <main>
        <header>
            <img src="../../img/base/logo.svg" alt="" class="logo">
            <h1>Создание игр в Roblox Studio</h1>
        </header>

        <section>
            <h1>Программирование на Lua. События - Часть 2</h1>

            <h2>Введение</h2>
            <p>Это занятие продолжает тему предыдущего. Оно полностью посвящено работе с событиями в более сложных и интересных игровых механиках. Это заключительное занятие по основам программирования в LUA :)</p>
            <p class="important">Как говорилось ранее, события используются для того, чтобы создавать объекты, самостоятельно взаимодействующие с игроком и окружающим миром.</p>
            <p>В этом занятии мы посмотрим на применение событий для создания специфичных ситуаций и механик, а именно: создание взрывающихся объектов, телепорта, триггеров, а также разберем основу работы с массивами.</p>

            <h2>Продвинутое применение событий</h2>
            <h3>Задание 1 - Взрывающаяся дверь. Создание объектов в процессе игры</h3>
            <p>В этом задании нужно написать код, который будет взрывать и уничтожать дверь, открывая проход в следующую комнату, для этого мы будем использовать эффект взрыва Explosion.</p>
            <img src="img/Screenshot_1.png" alt="">
            <p>Вы могли уже встречаться с ним ранее, на занятии, посвященном эффектам, но, скорее всего, он работал неправильно. Это связано с тем, что эффект взрыва необходимо создавать и настраивать при помощи программного кода.</p>
            <p class="story">Создадим дочерний скрипт для двери и назовём его ExplosionScript. В первую очередь зададим все необходимые переменные, обработчик события и его функцию:</p>
            <img src="img/Screenshot_2.png" alt="">
            
            <p>Следующим шагом создадим взрыв, то есть эффект Explosion. Чтобы сделать это при помощи программного кода, необходимо обратиться к главному классу Instance и создать новый объект заданного типа.</p>
            <p>Это делается при помощи конструкции <b>Instance.new()</b>. В скобках метода new() необходимо указать тип создаваемого объекта. С помощью этого метода мы можем создавать любые объекты во время игры.</p>
            <img src="img/Screenshot_3.png" alt="">
            <p>При создании взрыв будет расположен в точке начала мировых координат, то есть его параметр Position будет установлен на (0.0.0).</p>
            <p class="story">Поэтому в первую очередь перенесем взрыв в координаты двери, после чего сделаем его дочерним объектом workspace, это необходимо для корректной работы скрипта:</p>
            <img src="img/Screenshot_4.png" alt="">
            <p>Запустим игру в режиме Run и проверим, работает ли скрипт. В момент запуска дверь взрывается, но физически дверь останется на месте. Добавим команду для уничтожения двери с помощью метода Destroy().</p>
            <p>Также добавим визуальный эффект и небольшое ожидание перед взрывом, чтобы игрок успел отойти. Для этого в функции напишем команды изменения цвета двери на красный, а также время ожидания в 2-3 секунды.</p>
            <img src="img/Screenshot_5.png" alt="">
            <p>Базовая часть скрипта готова! Если оставить код в текущем состоянии, событие взрыва и уничтожения двери вызовется касанием любого объекта в игре. Чтобы этого избежать, добавим конструкцию для отсеивания касаний любых объектов кроме игрока, пройденную в предыдущем занятии.</p>
            <p class="story">Найдём у коснувшихся объектов компонент Humanoid и выполним реакцию только в том случае, если он будет успешно найден (не будет равен значению nil):</p>
            <img src="img/Screenshot_6.png" alt="">
            <p>Готово!</p>

            <h3>Задание 2 - Телепорт</h3>
            <img src="img/Screenshot_7.png" alt="">
            <p>В этой задаче вам нужно попасть из одной части комнаты в другую, но есть проблема - между входом и выходом находится непроходимое пространство с огромным количеством зомби. Для того, чтобы перенестись над ними, нам предстоит написать скрипт телепорта. Поднявшись по лестнице, можно найти два одинаковых объекта на противоположных сторонах комнаты, это и есть телепорты.</p>
            <p class="story">У этого задания есть две версии: полегче и посложнее. Hапишем сперва версию полегче.</p>
            <p>Логика скрипта телепорта достаточно проста: при касании он изменяет координаты персонажа с текущих на координаты второго телепорта. Однако, этот скрипт должен работать одновременно с двумя телепортами.</p>
            <p class="story">В окне Explorer найдём группу TeleportSystem. Внутри нее есть два одинаковых объекта - Teleport и Teleport2. В каждом из них есть дочерняя деталь Gate - это та самая деталь, которая должна переместить игрока от одного телепорта к другому.</p>
            <img src="img/Screenshot_8.png" alt="">
            <p class="story">В группе TeleportSystem создадим дочерний скрипт TeleportScript. Зададим необходимые переменные, обработчики событий и их функции:</p>
            <img src="img/Screenshot_9.png" alt="">
            <p>Перед написанием скрипта перемещения персонажа из одной точки в другую, необходимо проговорить важные ограничения Roblox Studio в этой механике. Любой персонаж - это группа объектов, а у групп нет параметров Position, Scale и Rotate, поэтому переносить его нужно с помощью дочерних объектов - частей тела. Но если перенести персонажа за любую из частей тела, персонаж умрёт, так как мы буквально разберём его на части.</p>
            <p>Для работы с трансформациями персонажа или любого другого живого существа в Roblox Studio существует специальная деталь, которая называется HumanoidRootPart.</p>
            <p class="story">Чтобы найти её, раскроем в Explorer группу любого гуманоидного объекта, например, зомби. Внутри найдём нужную деталь.</p>
            <img src="img/Screenshot_10.png" alt="">
            <p>HumanoidRootPart невидима и у неё нет физического соединения с другими частями тела. Её единственная функция - хранить параметры трансформации персонажа. Именно благодаря этой детали мы сможем перенести персонажа, изменив её параметр Position. Любой персонаж полностью перемещается вслед за HumanoidRootPart.</p>
            <p class="story">Вернёмся к скрипту. Сперва добавим фильтрацию по объектам - нам необходимо сделать так, чтобы телепорт переносил только гуманоидных персонажей. Добавим уже знакомую конструкцию:</p>
            <img src="img/Screenshot_11.png" alt="">
            <p class="story">Теперь, когда мы точно уверены, что объекта Gate коснулся именно персонаж, добавим команды, переносящие его из положения Teleport1 в положение Teleport2, используя координаты детали HumanoidRootPart:</p>
            <img src="img/Screenshot_12.png" alt="">

            <p>Этого кода достаточно, дверь автоматически откроется, как только игрок коснётся пола перед выходом из локации. Но давайте добавим возможность обратного переноса в Teleport1.</p>
            <p class="story">Добавим функцию, переносящую персонажа из второго телепорта в первый и соответствующий обработчик события. Для этого просто скопируем функцию первого телепорта и поменяем точки назначения местами.</p>
            <img src="img/Screenshot_13.png" alt="">
            <p>Если попробовать воспользоваться телепортами сейчас, персонаж будет непрерывно перемещаться между первым и вторым телепортом без возможности из него выйти.</p>
            <p class="story">Для корректной работы этого скрипта добавим паузу между срабатыванием событий, то есть добавим функцию debounce():</p>
            <img src="img/Screenshot_14.png" alt="">
            <p class="story">Добавим вызов функции и завершим программу! Финальный код:</p>
            <img src="img/Screenshot_15.png" alt="">
            <p>Теперь, благодаря паузе между срабатываниями обработчиков события, мы можем переместиться из одного телепорта к другому и обратно через некоторое время.</p>
            <p>Задача решена!</p>

            <h2>Коллайдеры</h2>
            <h3>Задача 3 - Основы работы с коллайдерами</h3>
            <img src="img/Screenshot_16.png" alt="">
            <p>Здесь необходимо написать скрипт, активирующий и деактивирующий бандитов в комнате при входе в определённую область. Для этого используется специальный невидимый объект, который называется "триггер" или "коллайдер".</p>
            <p class="important">Коллайдеры - одна из самых используемых техник в играх. С их помощью игра может отслеживать положение игрока и выполнять какие-то действия в зависимости от его нахождения в заданных зонах.</p>
            <p>Например, когда в игре вы заходите в огонь, на самом деле огонь не наносит вам урона. Внутри объекта "огонь" находится небольшая область, которую игрок не видит во время игры. Как только вы в неё попадаете, запускается скрипт, наносящий какое-то количество урона в секунду. Этот урон будет наноситься вам, пока вы не выйдете из зоны огня, то есть не выйдете из коллайдера.</p>
            <p>При помощи коллайдеров реализовывается огромное количество различных интерактивных объектов. Чтобы открыть какой-нибудь сундук или дверь в игре, вам необходимо подойти к нему спереди на определенное расстояние, чтобы появилась кнопка "открыть". На самом деле перед любым таким сундуком находится невидимый коллайдер, который позволяет активировать функцию "открыть сундук" только если вы находитесь внутри него.</p>
            <p>Чтобы начать разговор с неигровым персонажем, вам также нужно подойти к нему на определённое расстояние. Как вы уже поняли, вокруг этого персонажа находится коллайдер, включающий реакцию, только если вы находитесь достаточно близко к нему.</p>
            <p>Разберёмся, как устроена эта задача. В комнате находятся бандиты, которые начинают преследовать и атаковать игрока, только если включена специальная глобальная переменная CanAttack, найдите её в окне Explorer. По умолчанию эта переменная выключена, её значение установлено в положение false, то есть бандиты не будут вас атаковать.</p>
            <p>Цель этой задачи - написать программный код, включающий и выключающий эту переменную в зависимости от нахождения игрока внутри коллайдера. Для этого мы будем использовать новый вид событий - TouchEnded. Это парное событие для события Touched, происходящее в момент, когда объект перестаёт регистрировать касания. В нашем случае - когда игрок выходит из коллайдера.</p>
            <img src="img/Screenshot_17.png" alt="">
            <p class="story">Найдём объект TriggerThugs - это коллайдер, с которым мы будем работать. Создадим для него дочерний скрипт и зададим необходимые переменные и функции для каждого события:</p>
            <img src="img/Screenshot_18.png" alt="">
            <p class="story">В первую очередь, как и в предыдущих задачах, отфильтруем ложные срабатывания - сделаем так, чтобы событие происходило, только когда коллайдер пересекается с игроком, то есть гуманоидным объектом.</p>
            <img src="img/Screenshot_19.png" alt="">
            <p class="story">Теперь добавим действия. После того, как мы убедились, что событие вызвал именно Humanoid, мы можем изменить значение переменной canAttack, таким образом включив бандитов:</p>
            <img src="img/Screenshot_20.png" alt="">
            <p class="story">Следующим шагом напишем функцию для выхода из коллайдера. Она выполняет такие же действия, единственное отличие - значение переменной bool. Скопируем текст функции oneTouch, вставим его в функцию onTouchEnded и поменяем значение true на false:</p>
            <img src="img/Screenshot_21.png" alt="">
            <p>Запустим игру и войдём в коллайдер. Сейчас всё будет работать, однако мы столкнёмся с тем, что бандиты будут случайным образом начинать и переставать идти, иногда будут дёргаться на месте, и скрипт будет работать не очень правильно.</p>
            <p>Это связано с тем, что внутри бандитов, как и внутри нашего игрового персонажа, находится компонент Humanoid. Из-за этого скрипт проверяет написанное в нём событие, убеждается, что через него прошёл гуманоидный объект бандит и, как и написано, изменяет своё значение на true, активируя и деактивируя бандитов.</p>
            <p>Чтобы избавиться от этой проблемы, допишем ещё одно условие.</p>
            <p class="story">Нужно убедиться, что коллайдер пересечён не бандитом. Для этого мы можем посмотреть на имя родительского объекта детали, пересёкшей коллайдер. У каждого бандита это имя будет "Thug", и мы можем дополнительно отсеять и их:</p>
            <img src="img/Screenshot_22.png" alt="">
            <p>Запустим игру и проверим работу скрипта. Теперь всё работает!</p>

            <h2>Работа с массивами</h2>
            <img src="img/Screenshot_23.png" alt="">
            <p>В этой задаче нам необходимо написать скрипт, который будет включать и выключать лампы на входе и выходе из коллайдера. В комнате находится 22 лампы и, если мы будем решать эту задачу теми способами, которыми мы работали ранее, нам придётся написать 22 функции для каждой лампы либо написать универсальную функцию и 22 раза вызвать её для каждой лампы, что не особо эффективно. Для решения таких задач используются массивы.</p>
            <p class="important">Массив — структура данных, которая хранит набор однотипных элементов. Например, массив чисел (10, -2, 0, 54) или массив слов (яблоки, груши, апельсины, сливы).</p>
            <p class="story">Чтобы создать массив, достаточно перечислить в фигурных скобках значения его элементов:</p>
            <p class="code">colors_array = {"красный", "зеленый", "синий"}<br>numbers_array = {-2, 0, 154}</p>
            <p>Каждый элемент массива имеет уникальный индекс (то есть свой номер), благодаря чему мы можем обращаться к каждому отдельном элементу по его индексу. Индексация массива (нумерация его элементов) в Lua начинается с 1, а не с 0, как в некоторых других языках программирования.</p>
            <p class="story">Чтобы обратиться к элементу массива, нужно написать название массива и в квадратных скобках указать его индекс:</p>
            <p class="code">colors_array[1]     --эта строка обратится к 1-ому элементу массива colors_array, то есть к слову "красный"<br>numbers_array[3]       --эта строка обратится к 3-ому элементу массива numbers_array, то есть к числу 154</p>
            <p class="story">Найдём коллайдер для ламп - TriggerLamps. Создадим дочерний скрипт Lampscripts и введём необходимые переменные, функции событий и их обработчики.</p>
            <img src="img/Screenshot_24.png" alt="">
            <p>Для переменной lamps мы используем специальную функцию GetChildren, она найдёт все дочерние объекты группы lamps и запишет их в массив. Теперь через эту переменную мы сможем обратиться к любой из ламп в массиве по её индексу.</p>
            <p>Напишем функцию для включения ламп. В ней нам необходимо написать цикл, выполняющий одно и то же действие последовательно для каждой лампы в массиве lamps.</p>
            <p>Для решения таких задач используются цикл for, который начинается со значения 1, то есть с первого объекта и работает до того момента, как значение переменной i не достигнет длины массива. Чтобы получить длину массива, используем знак # и имя массива. Такая конструкция автоматически найдёт длину массива и передаст её в программный код.</p>
            <p>Внутри цикла мы будем обращаться к каждой лампе по индексу. На каждом новом повторении цикла значение переменной i будет увеличиваться на единицу, а значит мы будем обращаться каждый раз к следующей лампе в списке. Этот цикл должен включать лампу, то есть изменять её параметр на какое-то значение, отличное от нуля.</p>
            <p class="story">Запишем эту функцию:</p>
            <img src="img/Screenshot_25.png" alt="">
            <p>Запустим игру и проверим работу функции. Теперь лампы загораются в момент, когда игрок заходит внутрь коллайдера.</p>

            <p class="story">Напишем функцию для выхода из коллайдера и автоматического выключения ламп. Эта функция будет такой же, как и предыдущая за исключением того, что переменная active будет устанавливаться в значение false, а яркость ламп переключаться в нулевое значение, то есть выключаться:</p>
            <img src="img/Screenshot_26.png" alt="">
            <p>Теперь можно написать дополнительную часть задачи и заставить лампочки мерцать. Для этого у нас есть переменная active - когда она включена, лампы должны случайным образом изменять свою яркость.</p>
            <p class="story">Создадим функцию blink, которая будет ждать случайное количество времени, выключать лампу, потом снова ждать случайное количество времени и изменять яркость лампы в диапазоне от 0.05 до 0.5:</p>
            <img src="img/Screenshot_27.png" alt="">
            <p class="story">Добавим вызов этой функции для каждой лампы в массиве, используя цикл while, в функцию onTouch:</p>
            <img src="img/Screenshot_28.png" alt="">
            <p>Запустим игру и проверим работу кода. Программа готова!</p>



            <hr>
            <h1>Домашкаа 😁</h1>
            <p>Нужно повторить весь материал по программированию, изученный ранее.</p>
            <p>Мы завершили самый сложный блок с изучением основ программирования на Lua, поэтому можно похвалить себя и немного отдохнуть ;)</p>

        </section>
    </main>
</body>

</html>
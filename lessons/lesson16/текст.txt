1. Что такое функция
Ульяна
1.1. Функции в программировании
Это занятие завершает первый модуль, посвященный программированию, и в нём нам предстоит познакомиться с таким важным концептом как функция. Как всегда, прежде чем приступить к практической части, разберём, что такое функция и для чего она используется.
На самом деле мы уже не раз встречались с ними. Команды print() и wait() - это встроенные функции языка LUA.
Функция - заранее написанная и предопределённая последовательность действий (алгоритм), которая, в отличие от простого программного кода, с которым мы работали ранее, не выполняется автоматически в момент нажатия на кнопку Play, а ожидает специальной команды для начала выполнения внутри скрипта.
Эта команда называется «вызов функции» - чтобы выполнить написанные в функции действия, нужно просто написать ее называние в программном коде.
Если сказать более образно, то создавая функцию мы «обучаем» объект делать какое-то сложное действие и говорим, что, когда мы напишем название этого действия, объект должен его выполнить.
Это можно сравнить с дрессировкой собак: когда у вас есть собака, не знающая команду «дай лапу», сколько бы вы ни пытались говорить ей эту команду, она не сможет ее выполнить. Однако, если собаку обучить этой команде один раз, в будущем она сможет совершать это сложное (для собаки) действие, просто услышав правильную фразу.
При этом собака, умеющая подавать лапу, не делает этого постоянно - она просто знает, что умеет это делать и ждет команды. Таким же образом и функция, единожды написанная в программном коде, не выполняется при запуске скрипта пока не будет вызвана в программном коде. Написав ее имя, мы автоматически выполним все
действия, описанные внутри нее.


Обычно функции применяются для экономии времени и оптимизации
программного кода, когда у вас есть достаточно сложное действие, состоящее
из нескольких команд и повторяющееся в разных местах программы.
Если этот код копировать и вставлять этот код - это сделает текст менее
читабельным и менее удобным для справок. Вместо этого мы можем создать
функцию, удобным образом ее назвать и выполнять это действие в нужных
местах всего лишь одной строкой.
1.2.Функции в Lua
Для того, чтобы написать функцию, необходимо написать ключевое
слово function и после этого указать имя функции.
Обратите внимание: после имени функции всегда должны стоять скобки
- это место для параметров функции, если они у неё присутствуют.
Для того чтобы написать функцию нужно написать следующую
конструкцию:
function Имяфункции()
Действия
End
Рассмотрим использование функций в языке Lua.


Первая задача знакомит с созданием и использованием функции. В ней необходимо написать простую функцию, открывающую дверь, к которой она прикреплена. При этом, в отличие от предыдущих решений, в этот раз мы напишем универсальную функцию, которая будет открывать любую дверь, вне зависимости от размеров двери.
Создайте скрипт внутри группы Task1 и сделайте ссылку на дверь (Task1_Door). После этого начните писать функцию openDoor():


Алгоритм работы функции следующий: функция должна получить
высоту двери, после этого запустить цикл, который будет перемещать дверь
вниз на один юнит столько раз, сколько юнитов дверь составляет в высоту.
То есть, дверь в 20 юнитов нужно переместить вниз на 1 юнит 20 раз. Для двери в 35 юнитов - 35 раз.
Введите переменную height, которая будет хранить в себе высоту двери.
Эта переменная создается внутри функции, поэтому перед ней
необходимо поставить ключевое слово local - специальное обозначение, говорящее о том, что эта переменная доступна только внутри ее родительской
функции, а за ее пределами попросту не будет существовать.
После этого напишите цикл for, который будет перемещать дверь и
попросите детей запустить игру. Ничего не произойдет, проверьте их
внимательность и спросите, почему.
Добавьте вызов функции в конце программы, чтобы запустить написанную функцию:


Следующая задача сложнее предыдущей, но решается похожим
способом.
Здесь у вас есть поршень, находящийся под кнопкой. Необходимо
написать функцию, которая заставит поршень перемещаться наверх, пока он
не достигнет кнопки, а после этого вызвать другую функцию для открытия
двери.
В итоге вы создадите небольшую анимированную сцену, в которой
поршень начнёт двигаться наверх, нажмёт на кнопку, после этого двери
начнут двигаться вниз и вам откроется проход.
Эта задача создана, чтобы закрепить навык написания функций и
показать, что они могут вызвать другие функции внутри своего кода.
Для начала создайте скрипт в группе Task2 и скопируйте текст скрипта
из предыдущей задачи - благодаря тому, что мы написали универсальную
функцию, мы можем применить её и здесь.


Поменяйте ссылку на дверь, добавьте переменную со ссылкой на поршень и начните писать функцию для его анимации:
Способ передвижения поршня будет такой же, как и у двери, однако,
высота его передвижения не будет равна высоте поршня. Вам нужно
самостоятельно найти расстояние, на которое он должен подняться до того
момента, как упрется в кнопку. Для этого посмотрите на координаты поршня
в нижнем положении, переместите его в верхнее положение и найдите
разницу.
Если вы хотите пропустить этот шаг, используйте 20 повторений:
После окончания цикла, по условию задачи необходимо вызвать
функцию openDoor(). Для этого добавьте строку и напишите ее название.
Функция готова!


Добавьте вызов функции, небольшую паузу между движениями, и задача будет решена:
3. Параметры функций
3.1. Задача 3. Функция для поднятия ступеней
В этой задаче нам необходимо написать функцию, поднимающую ступени над лавой. Каждая ступень должна подняться на свое собственное количество юнитов, указанное на стене слева (5, 10, 15 и 20 юнитов
соответственно).


Если решать эту задачу способом, который мы использовали ранее, то
придётся написать пять разных функций - по одной на каждую высоту. Это
неэффективный способ, занимающий слишком много времени и пространства
в программном коде.
3.2.Функции с параметрами
Если мы будем использовать статичные значения, то другого варианта
нет. Однако, вместо них мы будем использовать переменную, которая будет
принимать разные значения в зависимости поднимаемой ступени. Назовем ее
height. Ступени тоже будут разные - для них введем переменную platform.
Чтобы понять, как решать такой тип задач, нужно подумать о ней не с
точки зрения конкретных чисел, а с точки зрения действий, которые должны
происходить и написать их алгоритм - абстрактную последовательность
действий, не опирающуюся на конкретные числа.
Общий алгоритм функции звучит так:
1. Получить значение переменной height для активной ступени
2. Переместить ступень step на 1 юнит. Повторить это действие height раз.
Действия, выполняющиеся для каждой ступени, абсолютно одинаковые,
изменяется только значение переменной height. При этом переменная height
должна изменяться в момент каждого вызова функции.
Такие переменные называются параметрами функции и задаются
особым образом - они указываются в скобках после имени функции. Их
значение указывается в скобках во время вызова функции.
Например:


В этом примере написана функция сложения, которая выводит сумму
двух чисел. В момент написания функции мы не знаем, какими будут эти
числа, но мы точно знаем, что они тут будут. Поэтому вместо значений мы
пишем, как в математических формулах, неизвестные - а и b. Это -
параметры функции, переменные, которые используются внутри для
описания алгоритма ее работы, без привязки к конкретным значениям.
Чтобы задать значение параметра, его необходимо вписать в скобках при
вызове функции - именно для этого скобки есть у каждой функции. В этом
примере Значение а - 6, b - 9.
Если вызвать эту функцию еще раз, но указать другие значения а и b, она
выполнит те же действия, но уже с другими значениями.
3.3. Запишем функцию с параметрами
Итак, вернемся к задаче. Создайте скрипт для группы Task3 введите
переменные для каждой ступени в уровне:
Далее необходимо написать функцию, которая будет поднимать ступень
platform на высоту height. Запишем это как функцию с двумя параметрами:


Добавим цикл для перемещения ступени, такой же, как и в предыдущих
задачах для двери:
Теперь при вызове функции мы можем указать при помощи параметров,
какая именно ступень (первый параметр) будет перемещаться, и на какое
расстояние (второй параметр).
Последовательно вызовем эту функцию для всех четырех платформ:
Готово!


4. *Встроенные функции Roblox. Методы Instance
Это дополнительная тема для старших групп. Если вы преподаете
младшим группам, и у вас осталось время на занятии, этот материал лучше
дать в форме демонстрации решения.
Помимо встроенных функций (print, wait и т.п.) и функций, которые мы
можем написать самостоятельно, в Roblox существуют также общие функции
для работы с объектами.
Это функции, позволяющие выполнять общие для всех объектов
действия: уничтожение, клонирование, получение дочерних или
родительских объектов и многое другое.
Такие функции вызываются специальным образом: нужно написать
название объекта поставить «:» и написать название функции. Например:
Harry = James:FindFirstChild()
BankZ:Destroy()
Таких функций в Roblox около 20 ( https://developer.roblox.com/en-us/api-
reference/class/Instance) и они могут работать только с объектами класса
Instance (это базовый родительский класс любого объекта в Roblox).


Такие функции, работающие только с одним классом, называются
методами.
В этом задании у вас уже есть скрипт, который нужно дополнить новой
функцией. В этом скрипте написан цикл, получающий количество дочерних
объектов в группе DestroyBlocks. Этот цикл будет выполняться, пока в ней не
останется ни одного дочернего объекта.
Ваша задача - написать функцию, которая будет уничтожать блоки,
находя первый дочерний объект в этой группе. Для этого мы будем использовать методы :FindFirstChild(), возвращающий первый найденный
дочерний объект сущности, для которой был вызван, и :Destroy(), уничтожающий объект.
Далее создадим локальную переменную block, в которую будем
записывать первый найденный в группе дочерний объект DestroyBlocks. Для этого используем метод :FindFirstChild(). В его скобки передадим параметр
name - это имя искомого блока.


После того, как мы нашли блок, его нужно уничтожить. Для этого
вызовем метод :Destroy() для переменной block:
Если оставить код в этом виде, то рано или поздно произойдет
следующая ошибка: код удалит все блоки с искомым названием, попытается
найти и записать в переменную block пустоту, а после попробует удалить ее в
следующей строке. Дойдя до этого момента, скрипт сломается и остановится.
Поэтому перед тем, как удалять объект в переменной block, нам нужно
проверить, не содержит ли она в себе пустоту, то есть не является ли она
«нулевой». Для этого сравним ее значение с ключевым словом nil - это
обозначение несуществующего значения, «пустоты».
Мы не можем удалить несуществующий объект, поэтому команда
:Destroy() должна выполняться только в том случае, если значение block не
является нулевым:
Теперь добавим в изначальный цикл вызов этой функции для всех трех
типов блоков в группе:


Домашка